---
title: 自作マイコンのアーキテクチャ RK16
date: 2023-03-26
keyword: 自作CPU, ISA
description: 自作マイコンRK16のISAとABIを解説しています。
---

## レジスタ

メモリ空間の上位16個(0x0000X)をレジスタとして割り当てます。

| アドレス        |         | 機能                 |     |
| --------------- | ------- | -------------------- | --- |
| 0x0000          | zero    | ゼロ固定             | R   |
| 0x0001          | pc      | プログラムカウンタ   | R   |
| 0x0002          | ira     | 割り込み戻りアドレス | R   |
| 0x0003          | csr     | 状態制御レジスタ     | RW  |
| 0x0004          | ra      | 戻りアドレス         | ✕   |
| 0x0005          | sp      | スタック・ポインタ   | 〇  |
| 0x0006          | fp      | フレーム・ポインタ   | 〇  |
| 0x0007          | -       | 用途未定             | 〇  |
| 0x0008 - 0x000b | s0 - s3 | 保存レジスタ         | 〇  |
| 0x000c - 0x000f | t0 - t3 | 一時レジスタ         | ✕   |

ロジックICでCPUを作る場合、レジスタは74HC564などのDフリップフロップを使用します。しかし、今回作るCPUはレジスタが多く(16個)、ロジックICの数が膨大(74HC564×32個)になってしまいます。そのため、このCPUでは、メインメモリのSRAMの一部を、レジスタとして使います。

レジスタをSRAMとして実装する問題点として、レジスタの値をリアルタイムに取得できないという問題があります。多くの自作CPUは、レジスタの値を直接LEDで見れるようになっています。

この問題を解消するため、メモリバースト転送という仕組みを実装します。
各クロックの最後のステージで、デバッガがRAMの内容を全て読み出します。
レジスタ値の変化をリアルタイムに見ることはできませんが、命令によるレジスタ値の変化を追跡することができます。

### 特殊レジスタ

レジスタをSRAMとして実装すると述べましたが、SRAMの入出力ポートは１つしかないので、複数のレジスタ値を常に取得し続けることができないという重大な問題があります。

そのため、4個のレジスタはSRAMではなく、独立したICで実装します。
アドレスの上位12ビットが0の場合 `0b0000_0000_0000_00xx` SRAMのCEをOFFにして、レジスタICのCEをONにします。（CE : Chip Enable 信号）

#### ゼロ・レジスタ

常にゼロを返すレジスタです。

#### プログラム・カウンタ

プログラムカウンタは、

通常のレジスタアクセスの手順で書き換えることができません。

#### 割り込み戻りアドレス

割り込みが発生したら、次のクロックでPCを割り込みのアドレス(0x0001)に変更し、割り込みの処理を行います。その時に、本来次に行くべきPCを退避しておくレジスタが、割り込みリターンアドレス (IRA : Interrupt Return Address) です。

#### 状態制御レジスタ

|     | csr     |     |                  |
| --- | ------- | --- | :--------------- |
| 0   | ien     | W   | 割り込み許可     |
| 1-7 | i0 - i6 | R   | 0-6番割り込み    |
| 8-f |         |     | 未定             |
| 8   | mode    |     | 特権モード（仮） |

### 汎用レジスタ

0x0004-0x000fは、汎用レジスタです。汎用レジスタは、ハードウェア的にはどれも同じなので好きに使っていいです。ただ、好き勝手に使うといろいろな問題が生じます。例えば、ライブラリによってレジスタの使い方が違うと、関数呼び出しの方法が変わったりして混乱が生じます。そのため、ABI (Application Binary Interface) でレジスタの使い方を定めています。

#### 戻りアドレス

#### スタックポインタ

#### フレームポインタ

## 命令セット

![](img/isa.png)

機械語的に見ると命令は `calc`,`calci`,`load`,`store`,`calif` の5種類です。しかし、アセンブラから見ると、??種類の命令があります。多くのアセンブラでは「疑似命令」と呼ばれるシンタックスシュガーを実装しています。例えば、RISC-Vでは、`add rd, rs, zero` を `mov rd, rs` と短縮して書くことができます。しかし、RKASMの疑似命令はシンタックスシュガーではありません。その特徴が一番現れているのが `calif` 命令です。`calif`をニーモニックとして使うことはできません。アセンブラ `if rs2 rs1 imm` は、内部的には `calif zero rs2 rs1 imm` と等価ですが、アセンブラ上で直接 `calif zero rs2 rs1 imm` と書くことはできません。別にこれを書けるようにしてもいいんですが、引数を4つも取ると、アセンブラが見にくくなるという問題があります。また実用上、引数4つをフルで使うことはない（どれかがzeroになる）ので、`calif`を直接呼び出せないようにしています。その代わりに、使い方に応じてニーモニック`if` `jump` `call` `ret` `iret` を割り当てています。これによって「生で書いてもわかりやすい＆バグりにくいアセンブラ」を実現します。

RK16の命令は「RAMから2回読み出し1回書き込む」という形式をとっています。これにより、全ての命令が同じステージ数で実行できるようになり、命令デコーダ (ID:Instruction Decoder) の回路を簡略化できます。

機械語命令は5種類あるので、命令ビットは 3 ビットで済むはずです。また、バイナリ中で最も多く出現する `mov` 命令は、意味のあるビットは 12/32 と、命令空間をかなり無駄遣いしています。つまり、この命令セットは情報量に対してかなり余剰なROM空間を消費するということになります。一般的に、特にROM空間が限られる組み込みにおいて、命令セットはバイナリ長が短くなるものが良いです。しかし、RKISAはロジックICで実装するために、ハードウェアの削減に重きをおいています。命令デコーダ(ID)の実装が楽になるように、あえて余分なビットを使っています。

### 演算命令

| 命令         | ASM             | 処理           |
| ------------ | --------------- | -------------- |
| レジスタ演算 | add rd rs1 rs2  | rd = rs1 + rs2 |
| 即値演算     | addi rd rs1 imm | rd = rs1 + imm |

#### 算術演算

|     | 演算                 | ASM |                    |
| --- | -------------------- | --- | ------------------ |
| +   | 加算                 | add |                    |
| -   | 減算                 | sub |                    |
| &   | ビット AND           | and |                    |
| \|  | ビット OR            | or  |                    |
| ^   | ビット XOR           | xor |                    |
| ~   | ビット NOT           | not |                    |
| >>  | 右シフト（符号あり） | rss | シフトして符号拡張 |
| >>  | 右シフト（符号なし） | rsu | 0 埋め             |
| <<  | 左シフト             | ls  |                    |

#### 符号拡張 (Sign Extension) とは

4bit の符号付き整数を 8bit にしたい場合、正の数は 0 を埋めればいいですが、負の数は 1 を埋める必要になります。
符号付き整数の符号は、最上位 bit で表されるので、一般に、符号付き整数の bit 長を伸ばしたい場合、最上位ビットで埋める必要があります。
これが符号拡張です。

|     |      |          |
| --- | ---- | -------- |
| 1   | 0000 | 0001     |
|     | ↑↑↑← | **0**001 |
| 0   |      | 0000     |
|     | ↓↓↓← | **1**111 |
| -1  | 1111 | 1111     |

#### 比較演算

真偽型は、0x0000 のみを false とし、他は全て true とみなします。

|     | 演算                 | ASM   |                     |
| --- | -------------------- | ----- | ------------------- |
| ==  | 一致比較             | eq    |                     |
| <   | 大小比較（符号あり） | lts   | signed として比較   |
| <   | 大小比較（符号なし） | ltu   | unsigned として比較 |
|     | 論理キャスト         | lcast |                     |

比較演算は true = 0xFFFF false = 0x0000 を返します。
論理キャストは false(0x0000) 以外の値を 0xFFFF に変換します。
論理演算をビット演算で行えます。

### 移値命令

| 命令           | ASM               |                      |
| -------------- | ----------------- | -------------------- |
| アドレス間移動 | mov rd rs         | rd = rs              |
| 即値ロード     | loadi rd imm      | rd = imm             |
| メモリロード   | load rd rs1 imm   | rd = mem[rs1 + imm]  |
| メモリストア   | store rs2 rs1 imm | mem[rs1 + imm] = rs2 |

ロード命令は、メモリからレジスタに値を移動します。
ストア命令は、レジスタからメモリに値を移動します。

メモリのアドレスは、レジスタに入ってる値と即値を足します。(mem[rs1 + imm])

### 制御命令

| 命令     | ASM        | 処理                                     |
| -------- | ---------- | ---------------------------------------- |
| 条件呼出 |            | rd = PC + 1, if(rs2 == 0) PC = rs1 + imm |
| 条件分岐 | if rs2 imm | if(rs1 == 0) PC = imm                    |
| ジャンプ | jump imm   | PC = imm                                 |
| 関数呼出 | call imm   | ra = PC + 1, PC = imm                    |
| 関数復帰 | ret        | PC = ra                                  |
| 割込復帰 | iret       | PC = ira                                 |

プログラムの制御に関する命令は全てこれで実行できます。
この命令を生で呼び出すことは想定していません。
後述する疑似命令を使います。

### 割り込み

割り込みは関数呼び出しとほとんど同じです。
唯一の違いは、戻りアドレスをRAではなくIRAに保存する点です。

![](img/intr_timing.dio.svg)

1. 割り込み発生
2. 現在実行中の命令が終了したら
3. 次のPCをIRAに退避し、PCを割り込み命令アドレス0x0001にする
4. 割り込み禁止
5. 割り込み処理を実行
6. 割り込み許可（１クロック遅延）
7. 割り込み復帰
8. 元の処理を実行


#### 割り込み番号

| No  | 機能     |
| --- | -------- |
| 0   | リセット |
| 1   | 外部１   |
| 2   | 外部２   |
| 3   | 外部３   |
| 4   | タイマ１ |
| 5   | タイマ２ |
| 6   | タイマ３ |
| 7   | タイマ４ |

- Timer
- WDT (Watch Dog Timer)
- PWM
- DMA

## メモリ空間

メモリ空間は 0x1000 ごとにバンクに区切られていて、RAM以外のデバイスに置き換えられる。

| Addr            | Function         |
| --------------- | ---------------- |
| 0x0000 - 0x000F | Registor         |
| 0x0010 - 0x00FF | IO Ctrl Registor |
| 0x1000 - 0x2FFF | VRAM             |
| 0x3000 - 0xFFFF | RAM              |

### レジスタ

- 実体としては、SRAM の一部分
- 4bit でアクセスする → ISA でビットを節約できる

### IO

IO は SRAM とは別に Dual Port SRAM または DFF の IC を使って実装する。このアドレスへのメモリアドレスは、デバイスにスイッチ。

### VRAM (Dual access SRAM)

表示の候補として、

- 300 x 400 画素 x 白黒 2 段階 (1bit) = 120000 bit ~ 16bit x 8k
- テキスト表示（フォントを EEPROM に置いておく）

### RAM (SRAM)

### Program ROM (NOR Flash)

## 回路

![](img/arch.dio.svg)

### ID

命令デコーダ。機械語命令をもとに、マルチプレクサを切り替えて、データの経路を決める。

![](img/data_path.dio.svg)

4 クロックで 1 命令を実行する。

1. メモリを読み出し、RS1 に記録
2. メモリを読み出し、RS2 に記録
3. メモリに書き込み
4. PC のカウントアップ

```{.language-verilog}
`define CALC  4'b0000
`define CALCI 4'b0001
`define LOAD  4'b0011
`define STORE 4'b0111
`define CALIF 4'b1111

module ID(
    input  wire [31: 0] OP,
    output wire [ 3: 0] RS1,
    output wire [ 3: 0] RS2,
    output wire [ 3: 0] RD,
    output wire [31:16] IMM,
    output wire [ 1: 0] DIN_SEL,
    output wire [ 1: 0] ADDR_SEL,
    output wire [ 3: 0] ALU_CTRL,
    output wire         PFC_CTRL,
);

wire [3:0] OPC;

assign RS1 = OP[ 3: 0];
assign RS2 = OP[ 7: 4];
assign RD  = OP[11: 8];
assign OPC = OP[15:12];
assign IMM = OP[31:16];

assign ALU_CTRL = OPC==`CALC  ? OP[19:16]
                : OPC==`CALCI ? OP[ 7: 4]
                : `ALU_ADD;

assign ADDR_SEL = STAGE==0 ? `ADDR_RS1
                : STAGE==1 ? `ADDR_RS2
                : STAGE==2 ? `ADDR_RD;

assign DIN_SEL = OPC==`CALC|`CALCI ? `DIN_ALU 
               : OPC==`LOAD|`STORE ? `DIN_RS2
               : OPC==`CALLIF     ? `DIN_RA;

assign S2_SEL = OPC==`CALC ? `S2_RS2 
                           : `S2_IMM;

endmodule
```

|        | ALU  | S2  | DIN | 1.ADR | 2.ADR | 3.ADR |
| ------ | ---- | --- | --- | ----- | ----- | ----- |
| add    | Func | RS2 | ALU | RS1   | RS2   | RD    |
| addi   | Func | IMM | ALU | RS1   | -     | RD    |
| load   | ADD  | IMM | RS2 | RS1   | ALU   | RD    |
| store  | ADD  | IMM | RS2 | RS1   | RS2   | ALU   |
| callif | ADD  | IMM | RA  | RS1   | RS2   | RD    |

![](img/decoder.dio.svg)

### ALU

演算装置。必要な演算は、

|     | 演算                 | 実装           |
| --- | -------------------- | -------------- |
| +   | 加算                 | 74181          |
| -   | 減算                 | 74181          |
| &   | ビット AND           | 74181          |
| \|  | ビット OR            | 74181          |
| ^   | ビット XOR           | 74181          |
| ~   | ビット NOT           | 74181          |
| >>  | 右シフト（符号あり） | MUX            |
| >>  | 右シフト（符号なし） | MUX            |
| <<  | 左シフト             | 74181          |
| ==  | 一致比較             | 7485           |
| <   | 大小比較（符号あり） | 7485           |
| <   | 大小比較（符号なし） | 7485 + MSB NOT |

74HC181 で実装する。

| 74181 | Cn  | M   | S~3~ | S~2~ | S~1~ | S~0~ |
| ----- | --- | --- | ---- | ---- | ---- | ---- |
| ADD + | 0   | 0   | 1    | 0    | 0    | 1    |
| SUB - | 1   | 0   | 0    | 1    | 1    | 0    |
| AND & | -   | 1   | 1    | 1    | 1    | 0    |
| OR \| | -   | 1   | 1    | 0    | 1    | 1    |
| XOR ^ | -   | 1   | 1    | 0    | 0    | 1    |
| NOT ~ | -   | 1   | 0    | 0    | 0    | 0    |

### クロック

![](img/timing.dio.svg)

### PFC

プログラムフローコントローラ。プログラムの流れの変化を処理します。

![](img/pfc.dio.svg)
