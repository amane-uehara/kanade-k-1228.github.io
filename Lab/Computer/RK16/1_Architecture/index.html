<!-- (ฅ^･ω･^ฅ) ﾆｬｰ -->

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja" prefix="og: http://ogp.me/ns#">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-114187773-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());
    gtag("config", "UA-114187773-1");
  </script>
  <!-- End Google Analytics -->
  <!-- Load Google Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Kosugi+Maru&display=swap" rel="stylesheet">
  <!-- End Google Font -->

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="@kanade_k_1228" />
  <link rel="shortcut icon" href="https://avatars.githubusercontent.com/u/54773334" />
    <meta name="dcterms.date" content="2023-03-26" />
      <meta name="description" content="ロジックICを使った自作マイコンのアーキテクチャです。" />
    <title>自作マイコンのアーキテクチャ RK16 | Kanade's Website</title>

  <!-- OGP -->
    <!-- END OGP -->
  <link rel="stylesheet" href="https://kanade-k-1228.github.io/.common/style.css" />
    <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    mjx-container[jax="CHTML"][display="true"] {
      display: block;
      text-align: center;
      margin: 0;
    }
  </style>
  <!-- SyntaxHighlight -->
  <link rel="stylesheet" href="https://kanade-k-1228.github.io/.common/highlight.css" />
  <script src="https://kanade-k-1228.github.io/.common/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>

  <script>
    function tweet() {
      window.open(
        "https://twitter.com/intent/tweet?via=kanade_k_1228&related=kanade_k_1228&url=" +
        location.href +
        "&text=" +
        "自作マイコンのアーキテクチャ RK16",
        "_blank"
      );
    }
  </script>
</head>

<body>
  <article>
    <header>
      <ul>
        <li><a href="/">ﾎｰﾑ</a></li>
        <li><a href="/Portfolio/">ﾎﾟﾄﾌｫﾘｵ</a></li>
        <li><a href="/Lab/">研究室</a></li>
        <li><a href="/Blog/">雑記</a></li>
      </ul>
      <div id="header-links">
        <a href="https://twitter.com/kanade_k_1228" target="_blank">
          <svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="126.444 2.281 589 589"
            style="margin: 0; padding: 0">
            <circle cx="420.944" cy="296.781" r="294.5" fill="#2daae1" />
            <path
              d="M609.773 179.634c-13.891 6.164-28.811 10.331-44.498 12.204 16.01-9.587 28.275-24.779 34.066-42.86a154.78 154.78 0 0 1-49.209 18.801c-14.125-15.056-34.267-24.456-56.551-24.456-42.773 0-77.462 34.675-77.462 77.473 0 6.064.683 11.98 1.996 17.66-64.389-3.236-121.474-34.079-159.684-80.945-6.672 11.446-10.491 24.754-10.491 38.953 0 26.875 13.679 50.587 34.464 64.477a77.122 77.122 0 0 1-35.097-9.686v.979c0 37.54 26.701 68.842 62.145 75.961-6.511 1.784-13.344 2.716-20.413 2.716-4.998 0-9.847-.473-14.584-1.364 9.859 30.769 38.471 53.166 72.363 53.799-26.515 20.785-59.925 33.175-96.212 33.175-6.25 0-12.427-.373-18.491-1.104 34.291 21.988 75.006 34.824 118.759 34.824 142.496 0 220.428-118.052 220.428-220.428 0-3.361-.074-6.697-.236-10.021a157.855 157.855 0 0 0 38.707-40.158z"
              fill="#fff" />
          </svg>
        </a>
        <a href="https://github.com/kanade-k-1228" target="_blank">
          <svg width="50px" height="50px" viewBox="0 0 1024 1024" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" clip-rule="evenodd"
              d="M8 0C3.58 0 0 3.58 0 8C0 11.54 2.29 14.53 5.47 15.59C5.87 15.66 6.02 15.42 6.02 15.21C6.02 15.02 6.01 14.39 6.01 13.72C4 14.09 3.48 13.23 3.32 12.78C3.23 12.55 2.84 11.84 2.5 11.65C2.22 11.5 1.82 11.13 2.49 11.12C3.12 11.11 3.57 11.7 3.72 11.94C4.44 13.15 5.59 12.81 6.05 12.6C6.12 12.08 6.33 11.73 6.56 11.53C4.78 11.33 2.92 10.64 2.92 7.58C2.92 6.71 3.23 5.99 3.74 5.43C3.66 5.23 3.38 4.41 3.82 3.31C3.82 3.31 4.49 3.1 6.02 4.13C6.66 3.95 7.34 3.86 8.02 3.86C8.7 3.86 9.38 3.95 10.02 4.13C11.55 3.09 12.22 3.31 12.22 3.31C12.66 4.41 12.38 5.23 12.3 5.43C12.81 5.99 13.12 6.7 13.12 7.58C13.12 10.65 11.25 11.33 9.47 11.53C9.76 11.78 10.01 12.26 10.01 13.01C10.01 14.08 10 14.94 10 15.21C10 15.42 10.15 15.67 10.55 15.59C13.71 14.53 16 11.53 16 8C16 3.58 12.42 0 8 0Z"
              transform="scale(64)" fill="#1B1F23" />
          </svg>
        </a>
        <a href="https://t.co/E5xtfEQs4A" target="_blank">
          <img src="http://kanade-k-1228.github.io/.common/niconico.png" width="50px" height="50px"
            style="border-radius: 50%" /></a>
        <a href="https://www.youtube.com/channel/UCoeuc9-XQ5EpeYSCn4ESpQw" target="_blank">
          <svg width="50px" height="50px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 333333 333333">
            <path
              d="M166667 0c92048 0 166667 74619 166667 166667s-74619 166667-166667 166667S0 258715 0 166667 74619 0 166667 0zm84195 132297s-1678-11849-6843-17052c-6545-6843-13873-6887-17223-7283-24036-1751-60138-1751-60138-1751h-63s-36085 0-60135 1751c-3363 409-10681 437-17223 7283-5168 5203-6811 17052-6811 17052s-1711 13904-1711 27838v13029c0 13905 1709 27837 1709 27837s1678 11849 6811 17061c6542 6843 15139 6621 18977 7350 13761 1314 58457 1710 58457 1710s36133-64 60169-1783c3363-397 10678-438 17223-7284 5168-5202 6843-17065 6843-17065s1711-13904 1711-27837v-13028c-35-13905-1745-27837-1745-27837l-9 9-1-1zm-102010 56674v-48312l46437 24237-46437 24075z"
              fill="red" />
          </svg>
        </a>
      </div>
      <!-- End Top Nav -->
      <!-- Title -->
            <h1 style="margin: 0">自作マイコンのアーキテクチャ RK16</h1>
            <!-- Date -->
            <p align="right">2023-03-26</p>
            <!-- Description -->
            <p>ロジックICを使った自作マイコンのアーキテクチャです。</p>
          </header>

    <!-- TeX Macros -->
    <!-- prettier-ignore -->
    <p style="display: none">
      \[ \newcommand{dn}[3]{\frac{\mathrm{d}^{#3} #1}{\mathrm{d} #2^{#3}}}
      \newcommand{\d}[2]{\frac{\mathrm{d} #1}{\mathrm{d} #2}}
      \newcommand{\dd}[2]{\frac{\mathrm{d}^2 #1}{\mathrm{d} {#2}^2}}
      \newcommand{\ddd}[2]{\frac{\mathrm{d}^3 #1}{\mathrm{d} {#2}^3}}
      \newcommand{\pdn}[3]{\frac{\partial^{#3} #1}{\partial {#2}^{#3}}}
      \newcommand{\pd}[2]{\frac{\partial #1}{\partial #2}}
      \newcommand{\pdd}[2]{\frac{\partial^2 #1}{\partial {#2}^2}}
      \newcommand{\pddd}[2]{\frac{\partial^3 #1}{\partial {#2}^3}}
      \newcommand{\p}{\partial}
      \newcommand{\D}[2]{\frac{\mathrm{D} #1}{\mathrm{D} #2}}
      \newcommand{\Re}{\mathrm{Re}}
      \newcommand{\Im}{\mathrm{Im}}
      \newcommand{\bra}[1]{\left\langle #1 \right|}
      \newcommand{\ket}[1]{\left|#1 \right\rangle}
      \newcommand{\braket}[2]{\left\langle #1 \middle|#2 \right\rangle}
      \newcommand{\inner}[2]{\left\langle #1 ,#2 \right\rangle}
      \newcommand{\l}{\left} \newcommand{\m}{\middle} \newcommand{\r}{\right}
      \newcommand{\f}[2]{\frac{#1}{#2}} \newcommand{\eps}{\varepsilon}
      \newcommand{\ra}{\rightarrow} \newcommand{\F}{\mathcal{F}}
      \newcommand{\L}{\mathcal{L}} \newcommand{\t}{\quad}
      \newcommand{\intinf}{\int_{-\infty}^{+\infty}}
      \newcommand{\R}{\mathcal{R}} \newcommand{\C}{\mathcal{C}}
      \newcommand{\Z}{\mathcal{Z}} \newcommand{\bm}[1]{\boldsymbol{#1}} \]
    </p>

    <!-- Table of Contents -->
        <nav><ul>
<li><a href="#レジスタ">レジスタ</a>
<ul>
<li><a href="#特殊レジスタ">特殊レジスタ</a></li>
<li><a href="#汎用レジスタ">汎用レジスタ</a></li>
</ul></li>
<li><a href="#メモリ">メモリ</a>
<ul>
<li><a href="#状態制御レジスタ">状態制御レジスタ</a></li>
<li><a href="#入出力制御レジスタ">入出力制御レジスタ</a></li>
<li><a href="#vram">VRAM</a></li>
<li><a href="#eeprom">EEPROM</a></li>
<li><a href="#ram">RAM</a></li>
<li><a href="#rom">ROM</a></li>
</ul></li>
<li><a href="#命令セット">命令セット</a>
<ul>
<li><a href="#演算命令">演算命令</a></li>
<li><a href="#転送命令">転送命令</a></li>
<li><a href="#制御命令">制御命令</a></li>
</ul></li>
<li><a href="#回路">回路</a>
<ul>
<li><a href="#命令の実行">命令の実行</a></li>
</ul></li>
<li><a href="#スタック">スタック</a></li>
<li><a href="#関数呼び出し">関数呼び出し</a></li>
<li><a href="#割り込み">割り込み</a>
<ul>
<li><a href="#例外">例外</a></li>
</ul></li>
</ul></nav>
     <h2 id="レジスタ">レジスタ</h2>
<p>メモリ空間の上位16個(0x000x)をレジスタとして割り当てます。</p>
<table>
<thead>
<tr class="header">
<th>アドレス</th>
<th></th>
<th>機能</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>特殊レジスタ</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>0x0000</td>
<td>zero</td>
<td>ゼロ固定</td>
<td>R</td>
</tr>
<tr class="odd">
<td>0x0001</td>
<td>ira</td>
<td>割り込み戻りアドレス</td>
<td>R</td>
</tr>
<tr class="even">
<td>0x0002</td>
<td>pc</td>
<td>プログラムカウンタ</td>
<td>R</td>
</tr>
<tr class="odd">
<td>0x0003</td>
<td>sp</td>
<td>スタックポインタ</td>
<td>R&amp;W</td>
</tr>
<tr class="even">
<td><strong>汎用レジスタ</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>0x0004</td>
<td>ra</td>
<td>戻りアドレス</td>
<td></td>
</tr>
<tr class="even">
<td>0x0005</td>
<td>fp</td>
<td>フレーム・ポインタ</td>
<td></td>
</tr>
<tr class="odd">
<td>0x0006 - 0x0007</td>
<td>a0 - a1</td>
<td>引数戻値レジスタ</td>
<td></td>
</tr>
<tr class="even">
<td>0x0008 - 0x000b</td>
<td>t0 - t3</td>
<td>一時レジスタ</td>
<td></td>
</tr>
<tr class="odd">
<td>0x000c - 0x000f</td>
<td>s0 - s3</td>
<td>保存レジスタ</td>
<td></td>
</tr>
</tbody>
</table>
<p>　ロジックICでCPUを作る場合、レジスタは74HC564などのDフリップフロップを使用します。しかし、今回作るCPUはレジスタが多く(16個)、ロジックICの数が膨大(74HC564×32個)になってしまいます。そのため、このCPUでは、メインメモリのSRAMの一部を、レジスタとして使います。</p>
<p>　レジスタをSRAMとして実装する問題点として、レジスタの値をリアルタイムに取得できないという問題があります。多くの自作CPUは、レジスタの値を直接LEDで見れるようになっています。</p>
<p>　この問題を解消するため、メモリバースト転送という仕組みを実装します。各クロックの最後のステージで、デバッガがRAMの内容を全て読み出します。レジスタ値の変化をリアルタイムに見ることはできませんが、命令によるレジスタ値の変化を追跡することができます。</p>
<h3 id="特殊レジスタ">特殊レジスタ</h3>
<p>　レジスタをSRAMとして実装すると述べましたが、SRAMの入出力ポートは１つしかないので、複数のレジスタ値を常に取得し続けることができないという問題があります。そのため、4個のレジスタはSRAMとは独立したDフリップフロップICで実装します。アドレスの上位12ビットが0の場合 <code>0b0000_0000_0000_00xx</code> SRAMのCE信号をOFFにして、DFFのCE信号をONにします。(CE:Chip Enable)</p>
<h4 id="ゼロレジスタzero">0. ゼロ・レジスタ(zero)</h4>
<p>　常にゼロを返すレジスタです。</p>
<h4 id="割り込み戻りアドレスira">1. 割り込み戻りアドレス(ira)</h4>
<p>　割り込みが発生したら、次のクロックでPCを割り込みのアドレス(0x0001)に変更し、割り込みの処理を行います。その時に、本来次に行くべきPCを退避しておくレジスタが、割り込みリターンアドレス (IRA : Interrupt Return Address) です。</p>
<h4 id="プログラムカウンタpc">2. プログラムカウンタ(pc)</h4>
<p>　現在実行中のプログラムのアドレスを指します。ただ、リードオンリーで通常のレジスタアクセスでは書き換えられません。PCを書き換えるには、制御命令を使う必要があります。</p>
<h4 id="スタックポインタsp">3. スタック・ポインタ(sp)</h4>
<p>　スタックの先頭を指したポインタです。push/pop命令でカウントアップ/カウントダウンされます。</p>
<h3 id="汎用レジスタ">汎用レジスタ</h3>
<p>　0x0004-0x000fは、汎用レジスタに割り当てられています。汎用レジスタは、それぞれに特殊な機能があるわけではなく、ハードウェア的にはどれも同じなのですが、標準的な使い方を ABI (Application Binary Interface) で規定しています。詳細は関数呼び出しの項で。</p>
<h4 id="戻りアドレスra">0. 戻りアドレス(ra)</h4>
<p>　関数の戻りアドレスを退避しておくレジスタです。</p>
<h4 id="フレームポインタfp">1. フレームポインタ(fp)</h4>
<p>　関数フレームの基底アドレスを指したポインタです。</p>
<h4 id="引数戻値レジスタa0-a1">2. 引数戻値レジスタ(a0-a1)</h4>
<p>　関数の引数を入れておくレジスタです。</p>
<h4 id="一時レジスタt0-t3">3. 一時レジスタ(t0-t3)</h4>
<p>　関数呼び出しの後で値が変化するレジスタです。</p>
<h4 id="保存レジスタs0-s3">4. 保存レジスタ(s0-s3)</h4>
<p>　関数側が関数の前後で値が変化しないことを保証するレジスタです。</p>
<h2 id="メモリ">メモリ</h2>
<p>　メモリマップドIOです。</p>
<table>
<thead>
<tr class="header">
<th>アドレス</th>
<th style="text-align: left;">機能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0x0000 - 0x000f</td>
<td style="text-align: left;">レジスタ</td>
</tr>
<tr class="even">
<td>0x0010 - 0x00ff</td>
<td style="text-align: left;">状態制御レジスタ</td>
</tr>
<tr class="odd">
<td>0x0100 - 0x0fff</td>
<td style="text-align: left;">入出力制御レジスタ</td>
</tr>
<tr class="even">
<td>0x1000 - 0x2fff</td>
<td style="text-align: left;">VRAM</td>
</tr>
<tr class="odd">
<td>0x3000 - 0x4000</td>
<td style="text-align: left;">EEPROM</td>
</tr>
<tr class="even">
<td>0x5000 - 0xffff</td>
<td style="text-align: left;">RAM</td>
</tr>
</tbody>
</table>
<h3 id="状態制御レジスタ">状態制御レジスタ</h3>
<p>　CSR (Control &amp; Status Registors)は、割り込み・例外・特権レベルなど、プロセッサの状態を保持するレジスタです。</p>
<table>
<thead>
<tr class="header">
<th>アドレス</th>
<th>R/W</th>
<th>機能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>W</td>
<td>割り込み許可</td>
</tr>
<tr class="even">
<td></td>
<td>W</td>
<td>割り込みマスク</td>
</tr>
<tr class="odd">
<td></td>
<td>R</td>
<td>割り込み番号</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>内部例外</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>※特権モード</td>
</tr>
</tbody>
</table>
<h3 id="入出力制御レジスタ">入出力制御レジスタ</h3>
<p>　入出力制御レジスタは、シリアル通信、PWM、ADCなど、入出力モジュールを制御するレジスタです。</p>
<h3 id="vram">VRAM</h3>
<p>　VRAMは、ディスプレイ表示用のRAMです。同時に2つのポートから読み書きができる Dual Port RAM を使って実装します。表示の方法として 2 種類のモードを切り替えることを考えています。</p>
<h4 id="ピクセル描画モード">ピクセル描画モード</h4>
<p>　ひとつはピクセル描画モードです。VRAM の bit と 300 x 400 ピクセルを一対一に対応させ白黒で描画します。必要な VRAM のサイズは 300 x 400 x 1 bit = 120000 bit = 16 bit x 7500 &lt; 16bit x 0x2000</p>
<h4 id="テキスト描画モード">テキスト描画モード</h4>
<p>　ふたつめはテキスト描画モードです。VRAM を 1 word ごと文字にして表示します。フォントを別の EEPROM に置いておき、描画時に組み合わせます。</p>
<h3 id="eeprom">EEPROM</h3>
<p>　メモリ空間中にEEPROMがあります。これは、定数値を置いておくための領域です。</p>
<h3 id="ram">RAM</h3>
<p>　メインの RAM です。SRAMで作ります。</p>
<h3 id="rom">ROM</h3>
<p>　ハーバードアーキテクチャなので、データを保持するRAM空間と別に、プログラムを保持するROM空間があります。ROM は高速な NOR Flash で作ります。</p>
<h2 id="命令セット">命令セット</h2>
<p><img src="img/isa.png" /></p>
<p>　機械語的に見ると命令は <code>calc</code>,<code>calci</code>,<code>load</code>,<code>store</code>,<code>calif</code> の5種類です。しかし、アセンブラから見ると、??種類の命令があります。多くのアセンブラでは「疑似命令」と呼ばれるシンタックスシュガーを実装しています。例えば、RISC-Vでは、<code>add rd, rs, zero</code> を <code>mov rd, rs</code> と短縮して書くことができます。しかし、RKASMの疑似命令はシンタックスシュガーではありません。その特徴が一番現れているのが <code>calif</code> 命令です。<code>calif</code>をニーモニックとして使うことはできません。アセンブラ <code>if sa2 sa1 imm</code> は、内部的には <code>calif zero sa2 sa1 imm</code> と等価ですが、アセンブラ上で直接 <code>calif zero sa2 sa1 imm</code> と書くことはできません。別にこれを書けるようにしてもいいんですが、引数を4つも取ると、アセンブラが見にくくなるという問題があります。また実用上、引数4つをフルで使うことはない（どれかがzeroになる）ので、<code>calif</code>を直接呼び出せないようにしています。その代わりに、使い方に応じてニーモニック<code>if</code> <code>jump</code> <code>call</code> <code>ret</code> <code>iret</code> を割り当てています。これによって「生で書いてもわかりやすい＆バグりにくいアセンブラ」を実現します。</p>
<p>　RK16の命令は「RAMから2回読み出し1回書き込む」という形式をとっています。これにより、全ての命令が同じステージ数で実行できるようになり、命令デコーダ (ID:Instruction Decoder) の回路を簡略化できます。</p>
<p>　機械語命令は5種類あるので、命令ビットは 3 ビットで済むはずです。また、バイナリ中で最も多く出現する <code>mov</code> 命令は、意味のあるビットは 12/32 と、命令空間をかなり無駄遣いしています。つまり、この命令セットは情報量に対してかなり余剰なROM空間を消費するということになります。一般的に、特にROM空間が限られる組み込みにおいて、命令セットはバイナリ長が短くなるものが良いです。しかし、RKISAはロジックICで実装するために、ハードウェアの削減に重きをおいています。命令デコーダ(ID)の実装が楽になるように、あえて余分なビットを使っています。</p>
<h3 id="演算命令">演算命令</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">命令</th>
<th style="text-align: left;">ASM</th>
<th style="text-align: left;">処理</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">レジスタ演算</td>
<td style="text-align: left;">add da sa1 sa2</td>
<td style="text-align: left;">[da] = [sa1] + [sa2]</td>
</tr>
<tr class="even">
<td style="text-align: left;">即値演算</td>
<td style="text-align: left;">addi da sa1 imm</td>
<td style="text-align: left;">[da] = [sa1] + imm</td>
</tr>
</tbody>
</table>
<h4 id="算術演算">算術演算</h4>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: left;">演算</th>
<th>ASM</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>+</td>
<td style="text-align: left;">加算</td>
<td>add</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td>-</td>
<td style="text-align: left;">減算</td>
<td>sub</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td>&amp;</td>
<td style="text-align: left;">ビット AND</td>
<td>and</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td>|</td>
<td style="text-align: left;">ビット OR</td>
<td>or</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td>^</td>
<td style="text-align: left;">ビット XOR</td>
<td>xor</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td>~</td>
<td style="text-align: left;">ビット NOT</td>
<td>not</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td>&gt;&gt;</td>
<td style="text-align: left;">右シフト（符号あり）</td>
<td>rss</td>
<td style="text-align: left;">シフトして符号拡張</td>
</tr>
<tr class="even">
<td>&gt;&gt;</td>
<td style="text-align: left;">右シフト（符号なし）</td>
<td>rsu</td>
<td style="text-align: left;">0 埋め</td>
</tr>
<tr class="odd">
<td>&lt;&lt;</td>
<td style="text-align: left;">左シフト</td>
<td>ls</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h4 id="符号拡張-sign-extension-とは">符号拡張 (Sign Extension) とは</h4>
<p>　4bitの符号付き整数を8bitにしたい場合、正の数は<code>0</code>を埋めればいいですが、負の数は<code>1</code>を埋める必要になります。符号付き整数の符号は、最上位ビットで表されるので、一般に、符号付き整数のビット長を伸ばしたい場合、最上位ビットで埋める必要があります。これが符号拡張です。</p>
<table>
<thead>
<tr class="header">
<th>dec</th>
<th></th>
<th>bin</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>0000</td>
<td>0001</td>
</tr>
<tr class="even">
<td></td>
<td>↖</td>
<td><strong>0</strong>001</td>
</tr>
<tr class="odd">
<td>0</td>
<td></td>
<td>0000</td>
</tr>
<tr class="even">
<td></td>
<td>↙</td>
<td><strong>1</strong>111</td>
</tr>
<tr class="odd">
<td>-1</td>
<td>1111</td>
<td>1111</td>
</tr>
</tbody>
</table>
<h4 id="比較演算">比較演算</h4>
<p>　真偽型は、0x0000 のみを false とし、他は全て true とみなします。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: left;">演算</th>
<th>ASM</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>==</td>
<td style="text-align: left;">一致比較</td>
<td>eq</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td>&lt;</td>
<td style="text-align: left;">大小比較（符号あり）</td>
<td>lts</td>
<td style="text-align: left;">signed として比較</td>
</tr>
<tr class="odd">
<td>&lt;</td>
<td style="text-align: left;">大小比較（符号なし）</td>
<td>ltu</td>
<td style="text-align: left;">unsigned として比較</td>
</tr>
<tr class="even">
<td></td>
<td style="text-align: left;">論理キャスト</td>
<td>lcast</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>　比較演算は true = 0xFFFF false = 0x0000 を返します。論理キャストは false(0x0000) 以外の値を 0xFFFF に変換します。論理演算をビット演算で行えます。</p>
<h3 id="転送命令">転送命令</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">命令</th>
<th style="text-align: left;">ASM</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">レジスタ間移動</td>
<td style="text-align: left;">mov da sa</td>
<td style="text-align: left;">[da] = [sa]</td>
</tr>
<tr class="even">
<td style="text-align: left;">即値ロード</td>
<td style="text-align: left;">loadi da imm</td>
<td style="text-align: left;">[da] = imm</td>
</tr>
<tr class="odd">
<td style="text-align: left;">メモリロード</td>
<td style="text-align: left;">load da sa1 imm</td>
<td style="text-align: left;">[da] = [[sa1] + imm]</td>
</tr>
<tr class="even">
<td style="text-align: left;">メモリストア</td>
<td style="text-align: left;">store sa2 sa1 imm</td>
<td style="text-align: left;">[[sa1] + imm] = [sa2]</td>
</tr>
</tbody>
</table>
<p>　ロード命令は、メモリからレジスタに値を移動します。ストア命令は、レジスタからメモリに値を移動します。メモリのアドレスは、レジスタに入ってる値と即値を足します。(mem[sa1 + imm])</p>
<h3 id="制御命令">制御命令</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">命令</th>
<th style="text-align: left;">ASM</th>
<th style="text-align: left;">処理</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">条件呼出</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">[da] = PC + 1, if([sa2] == 0) PC = [sa1] + imm</td>
</tr>
<tr class="even">
<td style="text-align: left;">条件分岐</td>
<td style="text-align: left;">if sa2 imm</td>
<td style="text-align: left;">if([sa1] == 0) PC = imm</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ジャンプ</td>
<td style="text-align: left;">jump imm</td>
<td style="text-align: left;">PC = imm</td>
</tr>
<tr class="even">
<td style="text-align: left;">関数呼出</td>
<td style="text-align: left;">call imm</td>
<td style="text-align: left;">[RA] = PC + 1, PC = imm</td>
</tr>
<tr class="odd">
<td style="text-align: left;">関数復帰</td>
<td style="text-align: left;">ret</td>
<td style="text-align: left;">PC = [RA]</td>
</tr>
<tr class="even">
<td style="text-align: left;">割込復帰</td>
<td style="text-align: left;">iret</td>
<td style="text-align: left;">PC = [IRA]</td>
</tr>
</tbody>
</table>
<p>　プログラムの制御に関する命令は全て <code>calif</code> で実行できます。</p>
<h2 id="回路">回路</h2>
<p><img src="img/arch.dio.svg" /></p>
<h3 id="命令の実行">命令の実行</h3>
<p>　RK16の命令は「RAMから2回読み出し1回書き込む」という形式をとっています。これを4ステージで実行します。</p>
<p><img src="img/data_path.dio.svg" /></p>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 19%" />
<col style="width: 19%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">ステージ</th>
<th style="text-align: left;"><code>calc</code></th>
<th style="text-align: left;"><code>calci</code></th>
<th style="text-align: left;"><code>load</code></th>
<th style="text-align: left;"><code>store</code></th>
<th style="text-align: left;"><code>calif</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1.Load</td>
<td style="text-align: left;">[sa1] =&gt; SR1<br/></td>
<td style="text-align: left;">[sa1] =&gt; SR1<br/>ALU(SR1,imm,func)</td>
<td style="text-align: left;">[sa1] =&gt; SR1<br/>ALU(SR1,imm,add)</td>
<td style="text-align: left;">[sa1] =&gt; SR1<br/>ALU(SR1,imm,add)</td>
<td style="text-align: left;">[sa1] =&gt; SR1<br/>ALU(SR1,imm,add)</td>
</tr>
<tr class="even">
<td style="text-align: left;">2.Load</td>
<td style="text-align: left;">[sa2] =&gt; SR2<br/>ALU(SR1,SR2,func)</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">[ALU] =&gt; SR2<br/></td>
<td style="text-align: left;">[sa2] =&gt; SR2<br/></td>
<td style="text-align: left;">[sa2] =&gt; SR2<br/>IS_ZERO(SR2)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3.Store</td>
<td style="text-align: left;">ALU =&gt; [da]</td>
<td style="text-align: left;">ALU =&gt; [da]</td>
<td style="text-align: left;">SR2 =&gt; [da]<br/>(SP+=sd)</td>
<td style="text-align: left;">SR2 =&gt; [ALU/SR1]<br/>(SP-=sd)</td>
<td style="text-align: left;">PC+1 =&gt; [da]</td>
</tr>
<tr class="even">
<td style="text-align: left;">4.Dump</td>
<td style="text-align: left;">PC+1 =&gt; PC</td>
<td style="text-align: left;">PC+1 =&gt; PC</td>
<td style="text-align: left;">PC+1 =&gt; PC</td>
<td style="text-align: left;">PC+1 =&gt; PC</td>
<td style="text-align: left;">IS_ZERO ? ALU : PC+1 =&gt; PC</td>
</tr>
</tbody>
</table>
<p><img src="img/stage_const.dio.svg" /></p>
<p>　命令に合わせて、各ステージの長さを調整することで、クロック（正確にはIPS）を上げられます。</p>
<p><img src="img/stage_fast.dio.svg" /></p>
<h2 id="スタック">スタック</h2>
<p>　RK16 では、スタックの pop / push とメモリの load / store を同じ命令で実行できます。正確にいえば、load/store命令のオプションとして、スタックポインタのインクリメント/デクリメントを行うことができます。RK16のビットフィールドを見ると、loadでは[11:8]が、storeでは[15:12]がオプションのフィールドです。また、load/storeのアドレスが計算された後にSPが変更されるため、pop命令では即値にオフセット1を指定する必要があります。</p>
<p>　また、余談ですが、標準的にはアドレスが減る方向に伸びますが、逆方向にスタックを伸ばすこともできるようにはなっています。コンパイラとかは対応していませんが暇があったら実装しようかな。スタックをアドレス増加方向に伸ばすと、スタックが予想外に伸びたときに、たいていはアドレスが小さい領域にある重要なデータを破壊せずに、セグメンテーション違反で止まってくれるとかいういいことがあるらしい。</p>
<h2 id="関数呼び出し">関数呼び出し</h2>
<p>　関数呼び出しの前後で変更していいレジスタと、いけないレジスタがあります。</p>
<p><a href="https://valinux.hatenablog.com/entry/20210624">参考１</a> <a href="https://inst.eecs.berkeley.edu/~cs61c/resources/RISCV_Calling_Convention.pdf">参考２</a></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">RKASM</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">関数呼び出し側の仕事 ←①</td>
</tr>
<tr class="even">
<td style="text-align: left;">push t0</td>
<td style="text-align: left;">一時レジスタを退避</td>
</tr>
<tr class="odd">
<td style="text-align: left;">push t1</td>
<td style="text-align: left;">関数呼び出し後に使わないなら</td>
</tr>
<tr class="even">
<td style="text-align: left;">push t2</td>
<td style="text-align: left;">退避する必要なし</td>
</tr>
<tr class="odd">
<td style="text-align: left;">push t3</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">push ra</td>
<td style="text-align: left;">RAを退避 (callで上書きされる)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">push fp</td>
<td style="text-align: left;">FPを退避 (FPは引数のポインタ)</td>
</tr>
<tr class="even">
<td style="text-align: left;">mov fp sp</td>
<td style="text-align: left;">SPを退避</td>
</tr>
<tr class="odd">
<td style="text-align: left;">mov a0 xx</td>
<td style="text-align: left;">引数を引数レジスタに入れる</td>
</tr>
<tr class="even">
<td style="text-align: left;">mov a1 yy</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">push zz</td>
<td style="text-align: left;">入らない引数はスタックに入れる</td>
</tr>
<tr class="even">
<td style="text-align: left;">push ww</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">call func</td>
<td style="text-align: left;">サブルーチンにジャンプ ←②</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">ここに戻ってくる ←③</td>
</tr>
<tr class="odd">
<td style="text-align: left;">mov sp fp</td>
<td style="text-align: left;">SPを復元</td>
</tr>
<tr class="even">
<td style="text-align: left;">pop fp</td>
<td style="text-align: left;">FPを復元</td>
</tr>
<tr class="odd">
<td style="text-align: left;">pop ra</td>
<td style="text-align: left;">RAを復元 ←④</td>
</tr>
<tr class="even">
<td style="text-align: left;">pop t3</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">pop t2</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">pop t1</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">pop t0</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">func:</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">push s0</td>
<td style="text-align: left;">保存レジスタの退避</td>
</tr>
<tr class="odd">
<td style="text-align: left;">push s1</td>
<td style="text-align: left;">関数内で上書きしなければ</td>
</tr>
<tr class="even">
<td style="text-align: left;">push s2</td>
<td style="text-align: left;">退避する必要なし</td>
</tr>
<tr class="odd">
<td style="text-align: left;">push s3</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">nop</td>
<td style="text-align: left;">関数の処理</td>
</tr>
<tr class="odd">
<td style="text-align: left;">pop s3</td>
<td style="text-align: left;">保存レジスタを復元</td>
</tr>
<tr class="even">
<td style="text-align: left;">pop s2</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">pop s1</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">pop s0</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">ret</td>
<td style="text-align: left;">元の処理に戻る</td>
</tr>
</tbody>
</table>
<h2 id="割り込み">割り込み</h2>
<p><img src="img/intr_timing.dio.svg" /></p>
<h4 id="割り込み発生">1. 割り込み発生</h4>
<p>割り込みは、割り込み入力ピン <code>i0</code>-<code>i7</code> を <code>1</code> にすることで発火できます。割り込み発生時に実行されている命令が終了したら、割り込み処理へ遷移します。</p>
<h4 id="割り込み開始">2. 割り込み開始</h4>
<p>実行中の命令が終了したら、割り込み処理へ移動します。</p>
<ol type="1">
<li>次のPCをIRAに退避します。</li>
<li>PCを割り込みのアドレス(0x0001)にします。</li>
</ol>
<h4 id="割り込み禁止">3. 割り込み禁止</h4>
<p>割り込み処理中に割り込みが発生しないように、割り込み許可ビットを<code>0</code>にします。</p>
<h4 id="割り込み処理の本体">4. 割り込み処理の本体</h4>
<p>割り込みの処理を行って、割り込みを解消します。</p>
<h4 id="割り込み許可">5. 割り込み許可</h4>
<p>割り込み処理から復帰する前に、割り込み許可ビットを<code>1</code>に戻します。変更が反映されるまで、ハードウェア的に1クロック遅延させています。割り込みから復帰する前に割り込みが発生すると、IRAが上書きされ、元の処理がわからなくなります。</p>
<h4 id="割り込みから復帰">6. 割り込みから復帰</h4>
<p><code>iret</code> 命令で割り込みから元の処理に戻ります。</p>
<h3 id="例外">例外</h3>
<ul>
<li>外部要因：命令に非同期
<ul>
<li>割り込み</li>
</ul></li>
<li>内部要因：命令の結果として生じる
<ul>
<li>トラップ
<ul>
<li>OSシステムコールの呼び出しなど</li>
</ul></li>
<li>フォールト
<ul>
<li>たぶん元の処理に戻る</li>
</ul></li>
<li>アボート
<ul>
<li>たぶん元の処理に戻らない</li>
</ul></li>
</ul></li>
</ul>

    <svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="126.444 2.281 589 589"
      style="margin: auto; padding: 0; display: block" onclick="tweet();">
      <circle cx="420.944" cy="296.781" r="294.5" fill="#2daae1" />
      <path
        d="M609.773 179.634c-13.891 6.164-28.811 10.331-44.498 12.204 16.01-9.587 28.275-24.779 34.066-42.86a154.78 154.78 0 0 1-49.209 18.801c-14.125-15.056-34.267-24.456-56.551-24.456-42.773 0-77.462 34.675-77.462 77.473 0 6.064.683 11.98 1.996 17.66-64.389-3.236-121.474-34.079-159.684-80.945-6.672 11.446-10.491 24.754-10.491 38.953 0 26.875 13.679 50.587 34.464 64.477a77.122 77.122 0 0 1-35.097-9.686v.979c0 37.54 26.701 68.842 62.145 75.961-6.511 1.784-13.344 2.716-20.413 2.716-4.998 0-9.847-.473-14.584-1.364 9.859 30.769 38.471 53.166 72.363 53.799-26.515 20.785-59.925 33.175-96.212 33.175-6.25 0-12.427-.373-18.491-1.104 34.291 21.988 75.006 34.824 118.759 34.824 142.496 0 220.428-118.052 220.428-220.428 0-3.361-.074-6.697-.236-10.021a157.855 157.855 0 0 0 38.707-40.158z"
        fill="#fff" />
    </svg>
  </article>
</body>

</html>